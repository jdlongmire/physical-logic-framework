LEAN 4 PROOF REQUEST: shannon_entropy_uniform Theorem

==============================================================================
CONTEXT
==============================================================================

Working on Sprint 12: Axiom Reduction in Physical Logic Framework
- Successfully proved kl_relation_to_entropy using team consultation (Grok 0.92/1.0)
- Current axiom count: 148 (targeting 141-143 by sprint end)
- Next target: shannon_entropy_uniform (fundamental information theory result)

==============================================================================
CURRENT AXIOM TO PROVE
==============================================================================

Location: lean/LFT_Proofs/PhysicalLogicFramework/Foundations/MaximumEntropy.lean:141

```lean
axiom shannon_entropy_uniform [Nonempty α] :
  ShannonEntropy (UniformDist : ProbDist α) = Real.log (Fintype.card α : ℝ) / Real.log 2
```

==============================================================================
DEFINITIONS (from MaximumEntropy.lean)
==============================================================================

```lean
-- Probability distribution structure
structure ProbDist (α : Type*) [Fintype α] where
  prob : α → ℝ
  prob_nonneg : ∀ x, 0 ≤ prob x
  prob_sum_one : (Finset.univ : Finset α).sum prob = 1

-- Uniform distribution
noncomputable def UniformDist [Nonempty α] : ProbDist α where
  prob := fun _ => 1 / (Fintype.card α : ℝ)
  prob_nonneg := by ...  -- proven
  prob_sum_one := by ...  -- proven

-- Shannon entropy
noncomputable def ShannonEntropy (P : ProbDist α) : ℝ :=
  -(Finset.univ : Finset α).sum fun x =>
    if P.prob x = 0 then 0
    else P.prob x * Real.log (P.prob x) / Real.log 2

-- Helper lemma (already proven)
lemma uniform_prob [Nonempty α] (x : α) :
  (UniformDist : ProbDist α).prob x = 1 / (Fintype.card α : ℝ) := rfl
```

==============================================================================
PROOF SKETCH (from comments)
==============================================================================

For uniform distribution P(x) = 1/n for all x:

Step 1: H[U] = -∑ (1/n) log₂(1/n)
Step 2: = -∑ (1/n) * (log(1/n) / log 2)
Step 3: = -∑ (1/n) * (-log(n) / log 2)    [since log(1/n) = -log(n)]
Step 4: = ∑ (1/n) * (log(n) / log 2)
Step 5: = (log(n) / log 2) * ∑ (1/n)       [factor out constant]
Step 6: = (log(n) / log 2) * n * (1/n)     [sum of n identical terms]
Step 7: = (log(n) / log 2) * 1
Step 8: = log(n) / log 2 = log₂(n)

==============================================================================
CHALLENGES FROM PREVIOUS ATTEMPT (Session 12.2)
==============================================================================

I attempted this proof and encountered several issues:

1. **Sum of constants pattern matching**:
   - Error: "Did not find an occurrence of the pattern Finset.card ?m.179 • ?b"
   - Tried: `Finset.sum_const` but couldn't apply it correctly
   - Challenge: Converting ∑ (1/n) to n * (1/n) = 1

2. **Negation handling**:
   - Entropy definition has outer negation: -∑ ...
   - Need to carefully track when to pull negation through
   - Logarithm has negative inside: log(1/n) = -log(n)
   - Multiple negations combine: -(-x) = x

3. **Field simplification**:
   - Expression: (1/n) * (-log n / log 2)
   - Need: (1/n) * log n / log 2 (after negation cancellation)
   - `field_simp` gave type mismatch errors

4. **Nonzero conditions**:
   - Need: (Fintype.card α : ℝ) ≠ 0
   - Available: `Fintype.card_ne_zero : Fintype.card α ≠ 0`
   - Challenge: Casting nat to real while preserving nonzero

==============================================================================
QUESTIONS FOR EXPERT CONSULTATION
==============================================================================

1. **What is the correct Lean 4 approach for sum of constants?**
   - How to prove: (Finset.univ : Finset α).sum (fun _ => 1/n) = n * (1/n)?
   - Should I use `Finset.sum_const`? If so, how?
   - Or is there a better tactic for this pattern?

2. **How to handle the multiple negations cleanly?**
   - Outer: -(sum ...)
   - Inner: log(1/n) = -log(n)
   - Result: -(...* (-log(n)/log 2)) = ... * (log(n)/log 2)
   - What's the cleanest tactic approach?

3. **What's the correct way to factor out the constant?**
   - ∑ (1/n) * c = c * ∑ (1/n)
   - Should I use `Finset.mul_sum` or `Finset.sum_mul`?
   - How to handle the constant being on the right vs. left?

4. **How to manage field arithmetic with casts?**
   - (Fintype.card α : ℝ) in denominators and numerators
   - Mixing natural number card with real arithmetic
   - Getting nonzero proofs through the cast

==============================================================================
DESIRED PROOF STRUCTURE
==============================================================================

```lean
theorem shannon_entropy_uniform [Nonempty α] :
  ShannonEntropy (UniformDist : ProbDist α) = Real.log (Fintype.card α : ℝ) / Real.log 2 := by
  unfold ShannonEntropy UniformDist
  simp only [uniform_prob]

  -- Step 1: Simplify the if-then-else (uniform prob is never zero)
  -- ... show 1/n ≠ 0 for finite n > 0

  -- Step 2: Expand log(1/n) = -log(n)
  -- ... use Real.log_inv or Real.log_div

  -- Step 3: Handle outer negation: -∑ (1/n) * (-log n / log 2)
  -- ... negations cancel to give positive sum

  -- Step 4: Factor constant: ∑ (1/n) * c = c * ∑ (1/n)
  -- ... use Finset.mul_sum or similar

  -- Step 5: Sum of constants: ∑ (1/n) = n * (1/n) = 1
  -- ... use Finset.sum_const

  -- Step 6: Final simplification: c * 1 = c
  -- ... done
```

==============================================================================
SUCCESS CRITERIA
==============================================================================

1. ✅ Complete proof that builds successfully
2. ✅ Clear step-by-step explanation with comments
3. ✅ Uses standard Mathlib lemmas (cite names)
4. ✅ Handles all edge cases (nonzero denominators, etc.)
5. ✅ Maintainable code (50-100 lines, well-commented)

==============================================================================
MATHLIB RESOURCES
==============================================================================

Potentially useful lemmas (not exhaustive):
- `Real.log_inv` : log(1/x) = -log(x)
- `Real.log_div` : log(a/b) = log(a) - log(b)
- `Finset.sum_const` : ∑ c = card * c
- `Finset.mul_sum` : c * ∑ f = ∑ (c * f)
- `Finset.sum_neg_distrib` : ∑ (-f) = -(∑ f)
- `Fintype.card_pos` : 0 < Fintype.card α
- `Fintype.card_ne_zero` : Fintype.card α ≠ 0
- `div_ne_zero` : a/b ≠ 0 if a ≠ 0 and b ≠ 0

==============================================================================
EXPECTED OUTPUT
==============================================================================

Please provide:

1. **Complete working proof** with all tactics and steps
2. **Explanation** of each major step (why this tactic?)
3. **Mathlib lemma citations** used in the proof
4. **Common pitfalls** to avoid in this type of proof
5. **Alternative approaches** if applicable

Quality target: 0.85+ score (complete, actionable, well-explained)

==============================================================================
ADDITIONAL CONTEXT
==============================================================================

- Lean 4 version: v4.23.0-rc2
- Mathlib: Latest stable
- Project: Physical Logic Framework (research codebase)
- Prior success: kl_relation_to_entropy proved with 0.92 quality consultation

Thank you for your expert guidance! This proof will reduce our axiom count from 148 to 147 and continues our systematic axiom reduction strategy.
